# Dynamic Programming – Introduction

## 1. What is Dynamic Programming?

Dynamic Programming (DP) is a problem-solving method used when:
- **Overlapping subproblems** exist (same problem solved multiple times)
- **Optimal substructure** property holds (optimal solution of problem can be constructed from optimal solutions of subproblems)

It stores and reuses solutions to subproblems to avoid recomputation.

---

## 2. Greedy Method vs Dynamic Programming

| Feature              | Greedy Method | Dynamic Programming |
|----------------------|--------------|---------------------|
| Decision Making      | Local optimum at each step | Considers all possibilities, chooses best overall |
| Problem Type         | Some optimization problems | Optimization & counting problems |
| Overlapping Subproblems | No need to revisit decisions | Frequently revisits, so stores results |
| Example              | Coin Change (min coins, when greedy works) | Coin Change (always works) |

---

## 3. Two Approaches to DP

### **A. Tabulation (Bottom-Up)**
- Solve subproblems starting from the smallest
- Store solutions in a table
- Build up to the main problem

### **B. Memoization (Top-Down)**
- Start with the main problem
- Recursively solve subproblems
- Store results in a cache (dictionary/array) to avoid recomputation

---

## 4. Example: Fibonacci Series

**Definition**:
\[
F(n) = \begin{cases} 
0 & \text{if } n=0 \\
1 & \text{if } n=1 \\
F(n-1) + F(n-2) & \text{if } n>1
\end{cases}
\]

---

### **A. Recursive without Memoization (Inefficient)**

```python
def fib_recursive(n):
    if n <= 1:
        return n
    return fib_recursive(n-1) + fib_recursive(n-2)
```

- Time Complexity: 𝑂(2^𝑛)– exponential
- Reason: Recomputes the same subproblems many times

  
### B. Memoization (Top-Down)
```python
def fib_memo(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 1:
        memo[n] = n
    else:
        memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo)
    return memo[n]
```
- Time Complexity:O(n)
- Space Complexity: O(n) for recursion + memo storage

### C. Tabulation (Bottom-Up)
```python
def fib_tab(n):
    dp = [0] * (n+1)
    dp[0], dp[1] = 0, 1
    for i in range(2, n+1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]
```
- Time Complexity:O(n)
- Space Complexity: O(n) (can be reduced to O(1) using tow variables)

## 5.Reducing Function Example

Example:

`fib(n)` calls → reduced from **exponential** to **linear** time using memoization or tabulation.

## 6. When to Use DP
- Problem shows **optimal substructure**
- Problem has **overlapping subproblems**
- When **brute force** or **greedy** approaches fail


## Applications
- Shortest paths (Bellman-Ford, Floyd-Warshall)
- Knapsack problem
- Matrix Chain Multiplication
- Longest Common Subsequence
- Edit Distance
- Optimal Binary Search Tree

## References
Abdul Bari – [Dynamic Programming Intro](https://www.youtube.com/watch?v=5dRGRueKU3M&list=PLDN4rrl48XKpZkf03iYFl-O29szjTrs_O&index=46&ab_channel=AbdulBari)
