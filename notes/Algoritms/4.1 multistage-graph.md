# Multistage Graph – Dynamic Programming


## Introduction

A **Multistage Graph** is a **directed weighted graph** where:
- Vertices are divided into **stages** (e.g., Stage 1, Stage 2, ..., Stage k)
- Edges only connect nodes from **stage i** to **stage i+1** (no backward edges)
- Goal: Find the **minimum cost path** from a **source node** in stage 1 to a **destination node** in stage k

---

## Characteristics

- Graph is **acyclic** (DAG)
- **Stages** are well-defined
- **Dynamic Programming** is used for optimal solution
- Can be solved **backward** from destination to source

---

## Problem Statement

Given:
- `G = (V, E)` where vertices are partitioned into stages
- Weighted edges between consecutive stages
- Find minimum cost from source `S` to destination `T`

---

## Dynamic Programming Approach

Let:
- `cost[i]` = minimum cost from vertex `i` to destination `T`

**Recurrence Relation**:

cost[i] = min_{(i,j) in E} { w(i,j) + cost[j] }

Where:
- \( w(i,j) \) = weight of edge from vertex `i` to vertex `j`
- \( cost[T] = 0 \)

---

## Algorithm Steps

1. Number vertices from **destination** backwards to **source**
2. Set `cost[T] = 0`
3. For each vertex `i` in reverse order:
   - For each neighbor `j`:
     - Compute `cost[i] = min(cost[i], w(i,j) + cost[j])`
4. Path reconstruction:
   - From `S`, choose the next vertex `j` that achieves the minimum

---

## Example

**Graph Stages**:
Stage 1: 1

Stage 2: 2, 3

Stage 3: 4, 5, 6

Stage 4: 7


**Edges with Weights**:

1 → 2 (2), 1 → 3 (1)

2 → 4 (2), 2 → 5 (3)

3 → 5 (2), 3 → 6 (4)

4 → 7 (3), 5 → 7 (1), 6 → 7 (2)


**Step-by-step DP Table**:

| Vertex | Min Cost to T | Next Vertex |
|--------|--------------|-------------|
| 7      | 0            | -           |
| 4      | 3            | 7           |
| 5      | 1            | 7           |
| 6      | 2            | 7           |
| 2      | 3 + 2 = 5    | 4           |
| 3      | min(2+1, 4+2) = 3 | 5       |
| 1      | min(2+5, 1+3) = 4 | 3       |

**Minimum Cost Path**: `1 → 3 → 5 → 7` with cost **4**

---

## Python Implementation

```python
def multistage_graph(cost_matrix, stages):
    n = len(cost_matrix)
    cost = [float('inf')] * n
    path = [-1] * n
    cost[-1] = 0  # destination cost is zero

    for i in range(n-2, -1, -1):
        for j in range(n):
            if cost_matrix[i][j] != 0:
                if cost_matrix[i][j] + cost[j] < cost[i]:
                    cost[i] = cost_matrix[i][j] + cost[j]
                    path[i] = j

    # reconstruct path
    current = 0
    result_path = [current]
    while path[current] != -1:
        current = path[current]
        result_path.append(current)

    return cost[0], result_path

# Example graph as adjacency matrix
graph = [
    [0, 2, 1, 0, 0, 0, 0],
    [0, 0, 0, 2, 3, 0, 0],
    [0, 0, 0, 0, 2, 4, 0],
    [0, 0, 0, 0, 0, 0, 3],
    [0, 0, 0, 0, 0, 0, 1],
    [0, 0, 0, 0, 0, 0, 2],
    [0, 0, 0, 0, 0, 0, 0]
]

min_cost, path = multistage_graph(graph, 4)
print("Minimum Cost:", min_cost)
print("Path:", path)

```
---

## Applications
- Project scheduling
- Stage-based network routing
- Layered decision-making problems
- Game level optimization

---

## References
Abdul Bari – [Multistage Graph Problem & Program](https://www.youtube.com/watch?v=FcScLYJI42E&list=PLDN4rrl48XKpZkf03iYFl-O29szjTrs_O&index=48&ab_channel=AbdulBari)
