# Strassen’s Matrix Multiplication Algorithm

##  Why Strassen?

Strassen’s algorithm reduces the number of multiplications in matrix multiplication compared to the standard method.

- **Classical Method**:  
  Multiplications = 8 for 2x2 matrices  
  Time Complexity = O(n³)

- **Strassen’s Method**:  
  Multiplications = 7  
  Time Complexity = **O(n^log₂7) ≈ O(n^2.81)**

---

## Key Idea

Given two matrices:

A = 
|     |    |
|-----|-----|
| A11 | A12 |
| A21 | A22 |

B = 
|     |    |
|-----|-----|
| B11 | B12 |
| B21 | B22 |

---

**Strassen computes 7 products instead of 8:**

M1 = (A11 + A22)(B11 + B22)

M2 = (A21 + A22)(B11)

M3 = (A11)(B12 - B22)

M4 = (A22)(B21 - B11)

M5 = (A11 + A12)(B22)

M6 = (A21 - A11)(B11 + B12)

M7 = (A12 - A22)(B21 + B22)

--- 

**Then, the resulting matrix is:**

C11 = M1 + M4 - M5 + M7

C12 = M3 + M5

C21 = M2 + M4

C22 = M1 - M2 + M3 + M6


---

## Python Code (2x2 Matrix)

```python
def strassen_multiply(A, B):
    if len(A) == 1:
        return [[A[0][0] * B[0][0]]]

    # Splitting matrices
    mid = len(A) // 2
    A11 = [row[:mid] for row in A[:mid]]
    A12 = [row[mid:] for row in A[:mid]]
    A21 = [row[:mid] for row in A[mid:]]
    A22 = [row[mid:] for row in A[mid:]]

    B11 = [row[:mid] for row in B[:mid]]
    B12 = [row[mid:] for row in B[:mid]]
    B21 = [row[:mid] for row in B[mid:]]
    B22 = [row[mid:] for row in B[mid:]]

    # Recursively compute the 7 products
    M1 = strassen_multiply(add(A11, A22), add(B11, B22))
    M2 = strassen_multiply(add(A21, A22), B11)
    M3 = strassen_multiply(A11, subtract(B12, B22))
    M4 = strassen_multiply(A22, subtract(B21, B11))
    M5 = strassen_multiply(add(A11, A12), B22)
    M6 = strassen_multiply(subtract(A21, A11), add(B11, B12))
    M7 = strassen_multiply(subtract(A12, A22), add(B21, B22))

    # Combine results
    C11 = add(subtract(add(M1, M4), M5), M7)
    C12 = add(M3, M5)
    C21 = add(M2, M4)
    C22 = add(subtract(add(M1, M3), M2), M6)

    return combine(C11, C12, C21, C22)

# Helper functions for matrix operations
def add(A, B):
    return [[A[i][j] + B[i][j] for j in range(len(A[0]))] for i in range(len(A))]

def subtract(A, B):
    return [[A[i][j] - B[i][j] for j in range(len(A[0]))] for i in range(len(A))]

def combine(C11, C12, C21, C22):
    top = [c11 + c12 for c11, c12 in zip(C11, C12)]
    bottom = [c21 + c22 for c21, c22 in zip(C21, C22)]
    return top + bottom
```
--- 

## Time Complexity

| Method             | Time Complexity           |
| ------------------ | ------------------------- |
| Classical          | O(n³)                     |
| Strassen           | O(n^2.81)                 |
| Best (Theoretical) | O(n².376) (not practical) |

- **Space Complexity**: O(n²)
- **Thresholding**: For small matrix sizes, classical method may be faster. Use hybrid approach in practice.

---

## Comparison
| Feature               | Classical | Strassen                      |
| --------------------- | --------- | ----------------------------- |
| Multiplications (2x2) | 8         | 7                             |
| Time Complexity       | O(n³)     | O(n^2.81)                     |
| Stability             | Stable    | Less stable (rounding errors) |
| Memory Usage          | Low       | High                          |

## Limitations
- Works best on square matrices with dimensions as power of 2 (e.g., 2x2, 4x4).
- Not numerically stable for floating point matrices.
- Requires more additions and subtractions (which may affect performance on small matrices).

---

## References
Abdul Bari – [Strassen’s Matrix Multiplication Video](https://www.youtube.com/watch?v=0oJyNmEbS4w&list=PLDN4rrl48XKpZkf03iYFl-O29szjTrs_O&index=38&ab_channel=AbdulBari)
