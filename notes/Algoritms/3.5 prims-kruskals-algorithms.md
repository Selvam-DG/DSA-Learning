# Prim’s and Kruskal’s Algorithms – Greedy Method

## 1. Spanning Tree – Basics

- **Spanning Tree (ST)**:  
  A subgraph of a **connected, undirected graph** that:
  1. Includes all vertices.
  2. Has **no cycles**.
  3. Has exactly **V – 1 edges** (where V = number of vertices).

- **Minimum Spanning Tree (MST)**:  
  A spanning tree where the **sum of edge weights** is **minimum** among all possible spanning trees.

---

## 2. MST in Weighted Graphs

- **Weighted Graph**: Each edge has an associated cost (weight).
- **MST algorithms** are used to find the cheapest way to connect all nodes without cycles.

---

## 3. Properties of MST
1. Unique MST if all edge weights are distinct.
2. Removing any edge from MST disconnects the graph.
3. Adding any edge to MST creates a cycle.

---

## 4. Prim’s Algorithm – Greedy Method

**Idea**:  
Grow the MST starting from an arbitrary vertex, at each step adding the **minimum weight edge** that connects a vertex inside the tree to a vertex outside.

### Steps:
1. Start with an arbitrary vertex.
2. Add the smallest edge that connects a vertex in the MST to one not in the MST.
3. Repeat until all vertices are included.

**Time Complexity**:
- Using adjacency matrix: `O(V^2)`
- Using min-heap + adjacency list: `O(E log V)`

---

### Prim’s Algorithm – Python Example

```python
import heapq

def prims_algorithm(graph, start):
    visited = set()
    min_heap = [(0, start)]  # (weight, vertex)
    total_cost = 0

    while min_heap:
        weight, u = heapq.heappop(min_heap)
        if u in visited:
            continue
        visited.add(u)
        total_cost += weight

        for v, w in graph[u]:
            if v not in visited:
                heapq.heappush(min_heap, (w, v))

    return total_cost

# Example graph as adjacency list
graph = {
    0: [(1, 4), (2, 3)],
    1: [(0, 4), (2, 1), (3, 2)],
    2: [(0, 3), (1, 1), (3, 4)],
    3: [(1, 2), (2, 4)]
}

print("MST Cost (Prim's):", prims_algorithm(graph, 0))
```

--- 
##  5. Kruskal’s Algorithm – Greedy Method

**Idea:**

Sort edges by weight, then repeatedly add the smallest edge that doesn’t form a cycle (using Disjoint Set/Union-Find to detect cycles).

**Steps:**
1. Sort all edges in non-decreasing order of weight.
2. Initialize an empty graph for MST.
3. For each edge:
  - If it connects two different trees (components), add it to MST.
4. Stop when MST has V – 1 edges.

**Time Complexity:**
- Sorting edges: O(E log E)
- Union-Find operations: O(E α(V)) (α = Inverse Ackermann function ≈ constant)

###  Kruskal’s Algorithm – Python Example
```python
class DisjointSet:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n

    def find(self, u):
        if self.parent[u] != u:
            self.parent[u] = self.find(self.parent[u])
        return self.parent[u]

    def union(self, u, v):
        root_u = self.find(u)
        root_v = self.find(v)
        if root_u != root_v:
            if self.rank[root_u] < self.rank[root_v]:
                self.parent[root_u] = root_v
            elif self.rank[root_u] > self.rank[root_v]:
                self.parent[root_v] = root_u
            else:
                self.parent[root_v] = root_u
                self.rank[root_u] += 1

def kruskals_algorithm(V, edges):
    edges.sort(key=lambda x: x[2])  # sort by weight
    ds = DisjointSet(V)
    total_cost = 0
    mst_edges = []

    for u, v, w in edges:
        if ds.find(u) != ds.find(v):
            ds.union(u, v)
            total_cost += w
            mst_edges.append((u, v, w))

    return total_cost, mst_edges

# Example usage
edges = [
    (0, 1, 4),
    (0, 2, 3),
    (1, 2, 1),
    (1, 3, 2),
    (2, 3, 4)
]
V = 4
cost, mst = kruskals_algorithm(V, edges)
print("MST Cost (Kruskal's):", cost)
print("MST Edges:", mst)
```
## 6. Special Cases
- Not Connected Graph:
  No spanning tree exists because you can’t connect all vertices.
- Missing Edges:
  If graph becomes disconnected due to missing edges, MST can’t be formed.

  ## Example Graph
  
  ``` 
   (0)---4---(1)
    | \       |
    3  1      2
    |   \     |
   (2)---4---(3)
  
``

- Prim’s: Start at vertex `0` → MST edges: `(0,2)`, `(2,1)`, `(1,3)` → Cost = 1 + 3 + 2 = 6
- Kruskal’s: Pick edges in order → `(1,2)`, `(1,3)`, `(0,2)` → Cost = 1 + 2 + 3 = 6


## Applications
- Network design (minimum wiring cost)
- Circuit design
- Cluster analysis in ML
- Road/railway layout planning

## References
- Abdul Bari – [Prim’s and Kruskal's Algorithm](https://www.youtube.com/watch?v=4ZlRH0eK-qQ&list=PLDN4rrl48XKpZkf03iYFl-O29szjTrs_O&index=44&ab_channel=AbdulBari)
