# Huffman Coding – Greedy Method


## Problem Statement

Huffman Coding is a **lossless data compression algorithm** that assigns variable-length binary codes to input characters.  
- **Frequent characters** → **shorter codes**  
- **Less frequent characters** → **longer codes**  
- **No code is a prefix of another** (Prefix-free property).

**Goal:** Minimize the total number of bits required to represent the data.

---

## Greedy Approach

**Idea**:
1. Build a binary tree by repeatedly combining the **two least frequent nodes**.
2. Assign:
   - `0` → left edge
   - `1` → right edge
3. Leaf nodes store characters, and their path from the root gives their code.

This is essentially the **Optimal Merge Pattern** applied to character frequencies.

---

## Algorithm Steps

1. Count frequency of each character.
2. Create a **min-heap** of nodes `(frequency, character)`.
3. While there is more than one node in the heap:
   - Extract two smallest frequency nodes.
   - Create a new internal node with frequency = sum of both.
   - Set extracted nodes as left and right children.
   - Insert the new node back into the heap.
4. The remaining node is the **root of the Huffman Tree**.
5. Traverse the tree to assign binary codes.

---

## Python Implementation

```python
import heapq

class Node:
    def __init__(self, char, freq):
        self.char = char
        self.freq = freq
        self.left = None
        self.right = None

    # For heapq to compare nodes
    def __lt__(self, other):
        return self.freq < other.freq

def huffman_coding(char_freq):
    heap = [Node(char, freq) for char, freq in char_freq.items()]
    heapq.heapify(heap)

    while len(heap) > 1:
        left = heapq.heappop(heap)
        right = heapq.heappop(heap)

        merged = Node(None, left.freq + right.freq)
        merged.left = left
        merged.right = right

        heapq.heappush(heap, merged)

    root = heap[0]
    codes = {}
    generate_codes(root, "", codes)
    return codes

def generate_codes(node, code, codes):
    if node:
        if node.char is not None:
            codes[node.char] = code
        generate_codes(node.left, code + "0", codes)
        generate_codes(node.right, code + "1", codes)
```
# Example usage
char_freq = {
    'a': 5,
    'b': 9,
    'c': 12,
    'd': 13,
    'e': 16,
    'f': 45
}

codes = huffman_coding(char_freq)
print("Huffman Codes:", codes)

---

##  Example
**Input:**
| Character | Frequency |
| --------- | --------- |
| a         | 5         |
| b         | 9         |
| c         | 12        |
| d         | 13        |
| e         | 16        |
| f         | 45        |

Steps to Build Tree:
1. Merge a(5) and b(9) → cost = 14
2. Merge c(12) and d(13) → cost = 25
3. Merge 14 and e(16) → cost = 30
4. Merge 25 and 30 → cost = 55
5. Merge f(45) and 55 → cost = 100 (root)

**Final Codes (example):**
```text
f: 0
c: 100
d: 101
a: 1100
b: 1101
e: 111
```
---

##  Time Complexity
- Building Heap: O(n)
- Extracting & merging: O(n log n)
- Overall: O(n log n)

---

## Applications
- Data compression formats (ZIP, GZIP)
- Multimedia codecs (MP3, JPEG)
- Transmission protocols to save bandwidth

---

## References
Abdul Bari – [Huffman Coding (YouTube)](https://www.youtube.com/watch?v=co4_ahEDCho&list=PLDN4rrl48XKpZkf03iYFl-O29szjTrs_O&index=43&ab_channel=AbdulBari)
